title=Java Release versions & History
date=2023-09-28
type=post
status=published
tags=Java
~~~~~~

My initial reference major Java releases.  Its focus is for application developers, so ignoring garbage collection & runtime tuning and many API details but highlighting major features & API releases.

While I captured some of the preview & incubator features relative to releases, they exist to expose developers to a concept and gather feedback prior to general releases.  They usually require special flags to be run and thus should not be relied on for production application deployments.

.Java Release History
[cols="1,1,6"]
|===
|Version | When | Impactful features

|**21 (LTS)** | 2023-SEP
    | standard: Record Patterns, `switch` Pattern Matching, Virtual Thread +
     _preview: String templates, Scoped Values, unnamed classes/instance main_
| 20 | 2023-MAR | _incubator: Scoped Values, several preview updates_
| 19 | 2022-SEP | _preview: Record Patterns, Virtual Threads_
| 18 | 2022-MAR
    | UTF-8 by default, deprecate finalization (`try...finally`), tool `jwebserver` to serve local static files +
    _preview: String templates_
| **17 (LTS)** | 2021-SEP
    | **supported by Spring 6 & Spring Boot 3**, Sealed classes +
    remove or deprecate several APIs, stronger encapsulation of internals (`com.sun.*, jdk.*, org.*`) +
    incubator Vector API (SIMD: single instruction, multiple data)
| 16 | 2021-MAR
    | enhance Records (may be member of inner class), add `Stream.toList()`, `instanceof` standard, packaging tool.
| 15 | 2020-SEP
    | text blocks standard, enhancements, remove Nashorn +
    _preview: sealed classes_
| 14 | 2020-MAR
    | standard `switch` expressions, helpful NPEs +
    _preview: `instanceof` Pattern Matching, Records_
| 13 | 2019-SEP
    | DOM/SAX factories with namespaces +
    _preview text blocks (multiline strings)_
| 12 | 2019-MAR
    | Microbenchmark Suite +
    _preview switch expressions_
| **11 (LTS)** | 2018-SEP
    | enhance String/Collection/Files/Optional, run single-file without compile,deprecate EE/CORBA/Nashorn/applets/JavaFX, tool "Flight Recorder" (JVM/OS events & visualizer)
| 10 | 2017
    | local variable type inference (`var list = new ArrayList<String>();`)
| 9 | 2017-SEP
    | Project Jigsaw (module system), enhance Collection/Stream/Process, interface private methods, JShell, tool `jlink`
| **8** | 2014-MAR
    | **Streams**, Lambdas, default methods, Optional.  JavaScript (Nashorn runtime), Date & time API
| 7 | 2011-JUL
    | `switch` Strings, try-with-resources, diamond operator, dynamic lang support (`invokedynamic`),
| 6 | 2006-DEC
    | performance, enhance annotations, upgrade JAXB (StAX parser), JDBC4, JavaScript Rhino engine
| 5 | 2004-SEP
    | Generics (type casts/conversions), Autoboxing (convert primitives to objects & back), Annotations, Enumerations (`enum`), varargs (String... lines), enhanced for..each, static imports, `java.util.concurrent`
| 1.4 | 2002-FEB
    | RegEx, logging API, JAXP (XML support), exception chaining, `assert` keyword, NIO (non-blocking IO), `java.util.prefs`, integrated security/crypto libs
| 1.3 | 2000-MAY
    | JNDI, JavaSound, RMI compatibility with CORBA, JPDA debugger API
| 1.2 | 1998-DEC
    | Collections framework, Swing UI, `strictfp` keyword, Java IDL (CORBA support)
| 1.1 | 1997-FEB
    | JDBC, JavaBeans, AWT, Inner classes, RMI, read-only reflection
| 1.0 | 1996-JAN
    | browser "WebRunner", networking
|===

=== Examples

Not covering Virtual Threads yet - I strive for FP (functional programming) to avoid direct thread management most of the time.

==== String templates, Text Blocks

Text Blocks equals multi-line strings with less punctuation in source code, including escaping characters.

.Basic Text Block (multi-line String)
[source,java]
----
jshell> String htmlTextBlock = """
   ...> <!DOCTYPE html>
   ...> <html lang="en">
   ...> <head>
   ...>   <meta charset="utf-8">
   ...> </head>
   ...> <body>
   ...> </body>
   ...> </html>""";
htmlTextBlock ==> "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  < ... n<body>\n</body>\n</html>"
----

Many languages support String Interpolation - but there is a risk for invalid String literals.  Java implementers wanted the convenience for developers with less risk and created String Templates.  They are a _preview_ feature and require `--enable-preview` to work.  Including because many other languages support a related syntax and we can anticipate what the feature should look like once standard.

.String Template Example (requires preview flag)
[source,java]
----
jshell> String name = "IT Gumby";
name ==> "IT Gumby"
jshell> Integer num = 42;
num ==> 42

jshell> String template = STR."""
   ...> Hello, friend!
   ...> My name is \{name} and the answer is always \{answer}
   ...> """;
template ==> "Hello, friend!\nMy name is IT Gumby and the answer is always 42\n"
----

==== instanceof Pattern Matching

Another convenience to save lines of code and reduce errors.

.instanceof simplification
[source,java]
----
jshell> Object obj = new String("my string");
obj ==> "my string"

// PREVIOUS
jshell> if (obj instanceof String) {
   ...>     String s = (String) obj;
   ...>     System.out.println(s);
   ...> }
my string

// NOW
jshell> if (obj instanceof String s) {
   ...>     System.out.println(s);
   ...> }
my string
----

==== Records

Write less code (thus less bugs) for **immutable objects**.
Records automatically get a constructor, equals(), toString() and "getters" that do NOT conform to the JavaBean standard (named after field without "get" prefix).
For this reason, libraries such as jackson require newer versions to support records.

.Record example
[code,java]
----
jshell> public record Book(String title, String author, String isbn) {};
|  created record Book
jshell> Book theHobbit= new Book("The Hobbit", "J.R.R. Tolkien", "0345339681");
theHobbit ==> Book[title=The Hobbit, author=J.R.R. Tolkien, isbn=0345339681]
jshell> theHobbit.author();
$1 ==> "J.R.R. Tolkien"

jshell> import java.lang.reflect.*;
jshell> for(var m : Book.class.getDeclaredMethods()) { System.out.println(m.getName());}
// => equals, toString, hashCode, title, author, isbn
----

==== switch enhancements

Including Pattern Matching...
.switch Pattern Matching
[code,java]
----
jshell> public record Car(int numSeats, String vin) {};
|  created record Car
jshell> var c = new Car(5, "my-vin");
c ==> Car[numSeats=5, vin=my-vin]

jshell> static double getValue(Object o) {
   ...>     return switch(o) {
   ...>         case Integer i -> i.doubleValue();
   ...>         case Float f -> f.doubleValue();
   ...>         case String s -> Double.parseDouble(s);
   ...>         case Car c -> c.numSeats();
   ...>         default -> 0d;
   ...>     };
   ...> }
|  created method getValue(Object)

jshell> getValue(c)
$7 ==> 5.0
jshell> getValue("17.01")
$8 ==> 17.01
jshell> getValue(3)
$9 ==> 3.0
----

Please excuse the horrible example, but it illustrates the new abilities to match by type and not require `break` statements if using statement expressions.

==== deprecation of finalization

There are cases where `finally {...}` blocks can leak, particularly if there is an exception in the main try block and another exception in the finally block.  This hasn't been removed yet but is marked for future removal.

Instead, use try-with-resources or `java.lang.ref.Cleaner` released in https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ref/Cleaner.html[Java 17].

==== Sealed Classes

Formerly known as Project Amber, sealed classes restrict which other classes & interfaces can extend or implement a sealed component.

New keywords: `sealed ... permits` (explicit subclassing), `final` (prevent subclassing), `non-sealed` (any can inherit)

As an application developer, I don't find sealed classes useful unless manipulating the type system ("Favor composition over inheritance").

=== Managing local Java development versions

I use https://brew.sh/[brew] (to install `jenv`), https://sdkman.io/[sdk] and https://github.com/jenv/jenv[jenv] to easily switch between java versions.

[source,bash]
----
sdk list java | grep 21
sdk install java 21-open ## not default yet, waiting for 1st patch release
jenv add ~/.sdkman/candidates/java/21-open/
jenv local 21 ## creates .java-version in current folder
java -version
# openjdk version "21" 2023-09-19
# OpenJDK Runtime Environment (build 21+35-2513)
# OpenJDK 64-Bit Server VM (build 21+35-2513, mixed mode, sharing)
----

=== Upgrade Ideas

https://docs.openrewrite.org/ and https://www.moderne.io/ propose to write "recipes" to automatically update source code in a consistent manner.  It is really worth evaluating this idea.  And if you are a library or dependency, it is worth considering adding to the recipes so your users can keep up with less effort.
