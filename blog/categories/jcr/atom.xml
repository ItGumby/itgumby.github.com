<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JCR | IT Gumby]]></title>
  <link href="http://ItGumby.github.io/blog/categories/jcr/atom.xml" rel="self"/>
  <link href="http://ItGumby.github.io/"/>
  <updated>2014-10-09T21:15:41-06:00</updated>
  <id>http://ItGumby.github.io/</id>
  <author>
    <name><![CDATA[Brian Street]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CQ Queries Demystified]]></title>
    <link href="http://ItGumby.github.io/blog/2014/10/cq-queries-demystified/"/>
    <updated>2014-10-09T18:36:00-06:00</updated>
    <id>http://ItGumby.github.io/blog/2014/10/cq-queries-demystified</id>
    <content type="html"><![CDATA[<p>The JCR (Java Content Repository) is a data-store at its heart.  Most examples around it demonstrate either building components or walking the Node tree.  It is hard to find examples around queries and the JCR.  To make things worse, we have a number of options and little resourcs to compare them.  My humble goal is to make JCR queries less scary &ndash; to myself and others.</p>

<p>== Why Use Queries?</p>

<p>I see 2 primary benefits to using queries compared to &ldquo;walking the nodes&rdquo;: efficiency and flexibility.</p>

<p>Queries can be <em>more efficient</em> when the desired nodes/pages are &ldquo;sparse&rdquo;.  By sparse, I mean you have to visit a lot more nodes than you keep.  In my recent experience, I was looking for approximately 200-300 pages out of 2,000.  Converting from page traversal to a query improved performance by an order of magnitude (from approximately 10 sec. to well under a second.)</p>

<p>Queries also permit <em>flexibility in structure</em>.  <a href="http://wiki.apache.org/jackrabbit/DavidsModel#Rule_.231">http://wiki.apache.org/jackrabbit/DavidsModel#Rule_.231</a>[David&rsquo;s Rules] encourage prioritizing content over formal structure.  If walking the tree of nodes or pages, a developer may limit depth of searching (either a flat level or limited recursion) for simplicity of code and/or performance.  However, in a CMS environment, there are tremendous benefits for authors when they can create an arbitrary taxonomy around their data or pages.</p>

<p>There are two primary APIs for Querying in CQ5:</p>

<ul>
<li><code>javax.jcr.query</code> provides a query interface API in a variety of syntaxes.  <a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/QueryResult.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/QueryResult.html</a>[QueryResult] can return <a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/NodeIterator.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/NodeIterator.html</a>[NodeIterators] or <a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/RowIterator.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/RowIterator.html</a>[RowIterators] (where a <a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/Row.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/Row.html</a>[Row] can have 1 or more columns. Columns can be +<a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/Node.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/Node.html</a>[Node]+ node,  +<a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/Value.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/Value.html</a>[Value]+ property, +String+ path or +double+ score).</li>
<li><code>com.day.cq.search</code> provides both a REST interface and an API.  The <a href="http://docs.adobe.com/docs/en/aem/6-0/develop/ref/javadoc/com/day/cq/search/result/SearchResult.html">http://docs.adobe.com/docs/en/aem/6-0/develop/ref/javadoc/com/day/cq/search/result/SearchResult.html</a>[SearchResult] can return +Iterator<Resource>+, +Iterator<Node>+, or +List<a href="http://docs.adobe.com/docs/en/aem/6-0/develop/ref/javadoc/com/day/cq/search/result/ResultPage.html[ResultPage]">http://docs.adobe.com/docs/en/aem/6-0/develop/ref/javadoc/com/day/cq/search/result/ResultPage.html[ResultPage]</a>+ that match the Predicates.</li>
</ul>


<p>=== Preconditions</p>

<p>CQ5 searches are &ldquo;powered by&rdquo; <a href="http://lucene.apache.org/">http://lucene.apache.org/</a>[Apache Lucene] (although AEM6 is converting to <a href="http://lucene.apache.org/solr/">http://lucene.apache.org/solr/</a>[Apache Solr]).  An important limitation is that indexing only examines Node properties that are 16KB or less in size &ndash; so anything larger won&rsquo;t be found by any searching mechanism.</p>

<p>Internally, the queries are converted to an AQM (Abstract Query Model).  The interesting aspect about AQM is the ability to create new query syntaxes and predicates &ndash; but that is well beyond the scope of this post.</p>

<p>=== NodeTypes</p>

<p>I recommend paying attention to the <a href="http://jackrabbit.apache.org/node-type-visualization.html">http://jackrabbit.apache.org/node-type-visualization.html</a>[NodeType] you use.  At the top of the hierarchy tree is <code>nt:base</code>, (so all nodes inherit from it).  Because of this inheritance, most examples show using it as a &ldquo;works anywhere&rdquo; approach.  However, I feel this is a poor approach and you would be better served selecting a more appropriate type (<code>jcr:primaryType</code> property of your desired nodes).  I would like to highlight:</p>

<ul>
<li><code>cq:Page</code> to match just <a href="http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/wcm/api/Page.html">http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/wcm/api/Page.html</a>[Page] nodes</li>
<li><code>cq:PageContent</code> to easily convert to <a href="http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/commons/inherit/InheritanceValueMap.html">http://dev.day.com/docs/en/cq/current/javadoc/com/day/cq/commons/inherit/InheritanceValueMap.html</a>[InheritanceValueMap] or <a href="http://dev.day.com/docs/en/cq/current/javadoc/org/apache/sling/api/resource/ValueMap.html">http://dev.day.com/docs/en/cq/current/javadoc/org/apache/sling/api/resource/ValueMap.html</a>[ValueMap]</li>
<li><code>nt:unstructured</code> to find content nodes for generic components or content</li>
</ul>


<p>== JCR Queries: <a href="http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/Query.html">http://www.day.com/specs/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/Query.html</a>[+javax.jcr.query+]</p>

<p>[cols=&ldquo;1,2,2&rdquo;, options=&ldquo;header&rdquo;]
.jcr.query Syntaxes
|===
|Syntax
|Cons
|Pros</p>

<p>|<a href="http://jackrabbit.apache.org/api/2.2/org/apache/jackrabbit/commons/query/sql2/package-summary.html">http://jackrabbit.apache.org/api/2.2/org/apache/jackrabbit/commons/query/sql2/package-summary.html</a>[SQL2]
|poor documentation +
no sub-queries +
limited joins
|&ldquo;looks&rdquo; like a query +
limited joins (K.I.S.S. principle)</p>

<p>|<a href="http://jackrabbit.apache.org/api/2.2/org/apache/jackrabbit/spi/commons/query/xpath/package-summary.html">http://jackrabbit.apache.org/api/2.2/org/apache/jackrabbit/spi/commons/query/xpath/package-summary.html</a>[XPath]
|&ldquo;strange&rdquo; syntax (<a href="http://zvon.org/comp/r/tut-XPath_1.html#intro">http://zvon.org/comp/r/tut-XPath_1.html#intro</a>[Tutorials exist]) +
deprecated in JCR2.0 (yet still supported) +
many XPath functions missing
|maturity &amp; performance +
generic (outside JCR) solution for structure/nodes/attributes</p>

<p>|<a href="http://www.day.com/maven/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/qom/QueryObjectModelFactory.html?is-external=true">http://www.day.com/maven/javax.jcr/javadocs/jcr-2.0/javax/jcr/query/qom/QueryObjectModelFactory.html?is-external=true</a>[JQOM]
|poor documentation
|build own query language/API</p>

<p>|SQL
|no longer supported
|N/A
|===</p>

<p>The best example I have found for comparing syntaxes is the <a href="https://wiki.magnolia-cms.com/display/WIKI/JCR+Query+Cheat+Sheet">https://wiki.magnolia-cms.com/display/WIKI/JCR+Query+Cheat+Sheet</a>[JCR+Query+Cheat+Sheet]</p>

<p>.Query Example</p>

<h2>[source,jsp]</h2>

<h2>include::source/_posts/jcr.query.jsp[]</h2>

<p>TIP: Prefer +Resource+ over +Node+.  It has a cleaner, easier to use API.</p>

<p>TIP: Leverage JSP Expression Language &amp; <a href="http://www.tutorialspoint.com/jsp/jsp_standard_tag_library.htm">http://www.tutorialspoint.com/jsp/jsp_standard_tag_library.htm</a>[JSTL] to keep the JSP Template simple &amp; clear.</p>

<p>== QueryBuilder API: <a href="http://docs.adobe.com/docs/en/cq/current/javadoc/com/day/cq/search/package-summary.html">http://docs.adobe.com/docs/en/cq/current/javadoc/com/day/cq/search/package-summary.html</a>[+com.day.cq.search+]</p>

<p>[cols=&ldquo;1,2,2&rdquo;, options=&ldquo;header&rdquo;]
.QueryBuilder Syntaxes
|===
|Syntax
|Cons
|Pros</p>

<p>| <a href="http://docs.adobe.com/docs/en/aem/6-0/develop/ref/javadoc/com/day/cq/search/QueryBuilder.html">http://docs.adobe.com/docs/en/aem/6-0/develop/ref/javadoc/com/day/cq/search/QueryBuilder.html</a>[Java API]
| More code to setup +
node property values must be extracted (just like JCR Queries)
| Iterators for Resources, Nodes (your choice) +
Lists of Pages (natural for search results pages) +
Predicates make &ldquo;sense&rdquo; as search conditions</p>

<p>| &ldquo;RESTful&rdquo; interface at <a href="http://docs.adobe.com/docs/en/aem/6-0/develop/search/querybuilder-api.html">http://docs.adobe.com/docs/en/aem/6-0/develop/search/querybuilder-api.html</a>[/bin/querybuilder.json]
| grouping predicates is more complex (naming predicates)
| dynamic at runtime +
documented examples of multi properties/values/nesting +
easy to test/explore via browser, +curl+
|===</p>

<p>.Query Example</p>

<h2>[source,jsp]</h2>

<h2>include::source/_posts/cq.search.jsp[]</h2>

<p>TIP: JSPs are best kept as templates with little to no Java in them.  In practice,
move the Java to an OSGi-managed class (Model).  If built outside of CQ5, this permits
rapid unit testing and potentially other JVM languages such as groovy.</p>

<p>== Troubleshooting</p>

<p><a href="http://helpx.adobe.com/experience-manager/kb/HowToDebugJCRQueries.html">http://helpx.adobe.com/experience-manager/kb/HowToDebugJCRQueries.html</a>[HowToDebugJCRQueries.html]
discusses adding loggers to a new file (separate from standard error.log) at the DEBUG level.
This logs the queries executed and their execution time.</p>
]]></content>
  </entry>
  
</feed>
